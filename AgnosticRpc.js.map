{"version":3,"sources":["node_modules/browser-pack/_prelude.js","AgnosticRpc.js","Utils.js"],"names":["AgnosticRpc","this","_requests","Utils","require","prototype","request","parsedArgs","parseArgs","arguments","name","level","validate","arg","allArgs","default","defaultOptions","multipleResponses","options","objectMerge","callback","requestId","uniqueId","query","id","handleResponse","message","response","handleRequest","requestMessage","requestCallback","responseEmitter","onResponse","responseMessage","messageIsResponse","messageIsRequest","module","exports","objectFilterProperties","object","properties","filtered","forEach","property","objectContainsObject","containerObject","hasOwnProperty","objectFilter","filter","result","objectForEach","child","parent","objectGet","keys","self","length","slice","Array","isArray","results","key","RegExp","match","value","index","objectSet","_objectSet","objectIsset","merged","argument","attrname","s4","Math","floor","random","toString","substring","argsPassed","argsConfig","validArg","argConfig","requiredLeftEnough","minIndex","required","matched","argConfigMin","call","ctr","callbackQueue","queueCompleteCallbackSafe","queueCompleted","queueCompleteCallback","apply","callbackQueueNext","queueFunctions","queueFunctionArgs","expand","concat","queueNoMatchCallback"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Utils = require('./Utils');\n\nfunction AgnosticRpc() {\n\tthis._requests = {};\n}\n\nAgnosticRpc.prototype.request = function() {\n\tvar parsedArgs = Utils.parseArgs(\n\t\targuments,\n\t\t[\n\t\t\t{name: 'query', level: 0,  validate: function(arg, allArgs) { return typeof arg == 'object'; }},\n\t\t\t{name: 'options', level: 1,  validate: function(arg, allArgs) { return typeof arg == 'object'; }, default: {}},\n\t\t\t{name: 'callback', level: 1,  validate: function(arg, allArgs) { return typeof(arg) === 'function'; }}\n\t\t]\n\t);\n\n\tvar defaultOptions = {\n\t\tmultipleResponses: false\n\t};\n\n\t// TODO add timeout option\n\tvar options = Utils.objectMerge(defaultOptions, parsedArgs.options); // merge options with defaults\n\n\tif(typeof parsedArgs.callback == 'function') {\n\t\tvar requestId = Utils.uniqueId();\n\t\tthis._requests[requestId] = {callback: parsedArgs.callback, options: options};\n\t}\n\n\tvar request = {\n\t\tquery: parsedArgs.query\n\t};\n\n\tif(typeof requestId != 'undefined')\n\t\trequest.id = requestId;\n\n\treturn request;\n};\n\nAgnosticRpc.prototype.handleResponse = function(message) {\n\tif(typeof message.id == 'string') { // responding to a logged request\n\t\tif(typeof this._requests[message.id] == 'object') { // request is logged\n\t\t\tvar request = this._requests[message.id];\n\t\t\tif(typeof request.callback == 'function') // valid callback is logged\n\t\t\t\trequest.callback(null, message.response); // callback with no error\n\t\t\tif(!request.options['multipleResponses'])\n\t\t\t\tdelete this._requests[message.id];\n\t\t}\n\t}\n\t// TODO trigger errors\n};\n\nAgnosticRpc.prototype.handleRequest = function(requestMessage, requestCallback, responseEmitter) {\n\tvar onResponse = function(response) {\n\t\tvar responseMessage = {\n\t\t\tresponse: response\n\t\t};\n\n\t\tif(typeof requestMessage.id == 'string')\n\t\t\tresponseMessage.id = requestMessage.id;\n\n\t\tresponseEmitter(responseMessage);\n\t};\n\n\trequestCallback(requestMessage.query, onResponse);\n\n\t// TODO trigger errors\n};\n\nAgnosticRpc.prototype.messageIsResponse = function(message) {\n\t// response to request from this node\n\treturn (typeof message.response != 'undefined');\n};\n\nAgnosticRpc.prototype.messageIsRequest = function(message) {\n\t// response to request from this node\n\treturn !this.messageIsResponse(message);\n};\n\nmodule.exports = function() {\n\treturn new AgnosticRpc();\n};","var Utils = {};\n\nUtils.objectFilterProperties = function(object, properties) {\n\t// get specified properties of an object into a new object\n\tvar filtered = {};\n\tproperties.forEach(function(property) {\n\t\tfiltered[property] = object[property];\n\t});\n\treturn filtered;\n};\n\nUtils.objectContainsObject = function(containerObject, object) {\n\t// return true if all the attributes of object are in containerObject and the values of all those attributes match (using ==)\n\tfor(var property in object) { // pull keys before looping through?\n\t\tif(object.hasOwnProperty(property) && (!containerObject.hasOwnProperty(property) || containerObject[property] != object[property]))\n\t\t\treturn false;\n\t}\n\treturn true;\n};\n\nUtils.objectFilter = function(object, filter) {\n\t// filter object properties (children) using filter function\n\t// similar to array filter function\n\tvar result = {};\n\tthis.objectForEach(object, function(child, property, parent) {\n\t\tif(filter(child, property, parent))\n\t\t\tresult[property] = child;\n\t});\n\treturn result;\n};\n\n\nUtils.objectForEach = function(object, callback) {\n\t// run function on each property (child) of object\n\tvar property;\n\tfor(property in object) { // pull keys before looping through?\n\t\tif (object.hasOwnProperty(property))\n\t\t\tcallback(object[property], property, object);\n\t}\n};\n\nUtils.objectGet = function(object, keys) {\n\tvar self = this;\n\tif(keys.length == 0)\n\t\treturn object;\n\telse if(typeof object === \"object\") {\n\t\tif((typeof keys[0] === \"string\" || typeof keys[0] === \"number\") && object !== null && object.hasOwnProperty(keys[0]))\n\t\t\treturn this.objectGet(object[keys[0]], keys.slice(1));\n\t\telse if(keys[0] === null) { // get all\n\t\t\tif(Array.isArray(object)) {\n\t\t\t\tvar results = [];\n\t\t\t\tobject.forEach(function(child, key) {\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar results = {};\n\t\t\t\tthis.objectForEach(object, function(child, key) {\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t\telse if(keys[0] instanceof RegExp) { // match keys to regexp\n\t\t\tvar results = {};\n\t\t\tthis.objectForEach(object, function(child, key) {\n\t\t\t\tif(key.match(keys[0]))\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t});\n\t\t\treturn results;\n\t\t}\n\t\telse if(typeof keys[0] === \"function\") { // apply a filtering function\n\t\t\tif(object instanceof Array) {\n\t\t\t\tvar results = [];\n\t\t\t\tobject.forEach(function(value, index, parent) {\n\t\t\t\t\tif(keys[0](value, index, parent)) // filter function\n\t\t\t\t\t\tresults[index] = self.objectGet(value, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar results = {};\n\t\t\t\tthis.objectForEach(self.objectFilter(object, keys[0]), function(result, key) {\n\t\t\t\t\tresults[key] = self.objectGet(result, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t\telse if(keys[0] instanceof Array) { // all members with keys in array\n\t\t\tif(object instanceof Array) {\n\t\t\t\tvar results = [];\n\t\t\t\tkeys[0].forEach(function(value, index) {\n\t\t\t\t\tresults[index] = object[index];\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar results = {};\n\t\t\t\tthis.objectForEach(self.objectFilterProperties(object, keys[0]), function(child, key) {\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t}\n\telse\n\t\treturn;\n};\n\nUtils.objectSet = function(object, keys, value) {\n\tif(keys.length == 1) {\n\t\tobject[keys[0]] = value;\n\t\treturn true;\n\t}\n\telse {\n\t\tif(typeof(object[keys[0]]) === \"undefined\")\n\t\t\tobject[keys[0]] = {}; // set empty object so we can descend into it\n\t\treturn this._objectSet(object[keys[0]], keys.slice(1), value);\n\t}\n};\n\nUtils.objectIsset = function(object, keys) {\n\tif(keys.length == 1)\n\t\treturn (typeof(object[keys[0]]) !== \"undefined\");\n\telse if(typeof(object[keys[0]]) === \"undefined\") // current level doesn't exist\n\t\treturn false;\n\telse\n\t\treturn this.objectIsset(object[keys[0]], keys.slice(1));\n};\n\nUtils.objectMerge = function() {\n\tvar merged = {};\n\tthis.objectForEach(arguments, function(argument) {\n\t\tfor (var attrname in argument) {\n\t\t\tif(argument.hasOwnProperty(attrname))\n\t\t\t\tmerged[attrname] = argument[attrname];\n\t\t}\n\t});\n\treturn merged;\n};\n\nUtils.uniqueId = function() {\n\tfunction s4() {\n\t\treturn Math.floor((1 + Math.random()) * 0x10000)\n\t\t\t.toString(16)\n\t\t\t.substring(1);\n\t}\n\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n\t\ts4() + '-' + s4() + s4() + s4();\n};\n\nUtils.parseArgs = function(argsPassed, argsConfig) {\n\tvar matched = {};\n\n\tfunction toLevels(argsConfig, level) {\n\t\tif(typeof level !== 'number')\n\t\t\tlevel = 0;\n\n\t\tvar levelsArr = [];\n\n\t\targsConfig.forEach(function(argConfig) {\n\t\t\tif(Array.isArray(argConfig))\n\t\t\t\tlevelsArr = levelsArr.concat(toLevels(argConfig, level + 1));\n\t\t\telse {\n\t\t\t\targConfig.level = level;\n\t\t\t\tlevelsArr.push(argConfig);\n\t\t\t}\n\t\t});\n\n\t\treturn levelsArr;\n\t}\n\n\tfunction validArg(argConfig, arg) {\n\t\treturn typeof argConfig.validate != 'function' || argConfig.validate(arg)\n\t}\n\n\tfunction requiredLeftEnough(argsConfig, minIndex) {\n\t\tfor(var index = minIndex; index < argsConfig.length; index++) {\n\t\t\tif(typeof(argsConfig[index]) === 'undefined' || !argsConfig[index].required)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvar argConfigMin = 0;\n\n\tif(!Array.isArray(argsPassed))\n\t\targsPassed = Array.prototype.slice.call(argsPassed);\n\n\targsPassed.forEach(function(arg, index) {\n\t\tfor(var ctr = argConfigMin; ctr < argsConfig.length; ctr++) {\n\t\t\tif(argsConfig[ctr].required) {\n\t\t\t\tif(validArg(argsConfig[ctr], arg)) {\n\t\t\t\t\targsConfig[ctr].matched = true;\n\t\t\t\t\tmatched[argsConfig[ctr].name] = arg;\n\t\t\t\t\targConfigMin++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthrow \"missing_required\";\n\t\t\t}\n\t\t\telse if((!argsConfig[ctr].required && (requiredLeftEnough(argsConfig, ctr) || (argsConfig[ctr].level > argsConfig[ctr - 1].level && argsConfig[ctr - 1].matched))) && validArg(argsConfig[ctr], arg)) {\n\t\t\t\targsConfig[ctr].matched = true;\n\t\t\t\tmatched[argsConfig[ctr].name] = arg;\n\t\t\t\targConfigMin++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\targsConfig[ctr].matched = false;\n\t\t\t\targConfigMin++;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Add default options, if set\n\targsConfig.forEach(function(argConfig) {\n\t\tif(typeof matched[argConfig.name] == 'undefined' && typeof argConfig.default != 'undefined')\n\t\t\tmatched[argConfig.name] = argConfig.default;\n\t});\n\n\treturn matched;\n};\n\n// queueFunctions [, queueFunctionArgs], queueCompleteCallback [, queueIncompleteCallback] [, options]\nUtils.callbackQueue = function() {\n\tvar parsedArgs = Utils.parseArgs(\n\t\targuments,\n\t\t[\n\t\t\t{name: 'queueFunctions', level: 0, validate: function(arg, allArgs) { return Array.isArray(arg); }},\n\t\t\t{name: 'queueFunctionArgs', level: 1, validate: function(arg, allArgs) { return Array.isArray(arg); }},\n\t\t\t{name: 'queueCompleteCallback', level: 0,  validate: function(arg, allArgs) { return typeof(arg) === 'function'; }},\n\t\t\t{name: 'queueNoMatchCallback', level: 1,  validate: function(arg, allArgs) { return typeof(arg) === 'function'; }},\n\t\t\t{name: 'options', level: 1, validate: function(arg, allArgs) { return typeof(arg) === 'object'; }, default: {}}\n\t\t]\n\t);\n\n\tparsedArgs.options = Utils.objectMerge({expand: false}, parsedArgs.options);\n\n\tvar queueCompleted = false;\n\tfunction queueCompleteCallbackSafe() {\n\t\tif(!queueCompleted) {\n\t\t\tqueueCompleted = true;\n\t\t\tparsedArgs.queueCompleteCallback.apply(this, Array.prototype.slice.call(arguments));\n\t\t}\n\t}\n\n\tvar index = -1;\n\tfunction callbackQueueNext() {\n\t\tindex++;\n\t\tif(typeof parsedArgs.queueFunctions[index] === 'function') {\n\t\t\tif(Array.isArray(parsedArgs.queueFunctionArgs) && !parsedArgs.options.expand) // pass arguments to function as array// TODO add expand option\n\t\t\t\tparsedArgs.queueFunctions[index](parsedArgs.queueFunctionArgs, callbackQueueNext, queueCompleteCallbackSafe);\n\t\t\telse if(Array.isArray(parsedArgs.queueFunctionArgs) && parsedArgs.options.expand) // pass arguments to function beforre done() and next()\n\t\t\t\tparsedArgs.queueFunctions[index].apply(this, parsedArgs.queueFunctionArgs.concat([callbackQueueNext, queueCompleteCallbackSafe]));\n\t\t\telse // no arguments to pass\n\t\t\t\tparsedArgs.queueFunctions[index](callbackQueueNext, queueCompleteCallbackSafe);\n\t\t}\n\t\telse if(typeof parsedArgs.queueNoMatchCallback == 'function' && !queueCompleted)\n\t\t\tparsedArgs.queueNoMatchCallback();\n\t}\n\n\tcallbackQueueNext();\n};\n\nmodule.exports = Utils;"]}